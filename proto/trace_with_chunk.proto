/*
 * A trace consists of header information and a list of instruction information. 
 * Different instructions have different information, so the main trick is to use 
 * variant type to represent instructions.
 *
 * Since protobuf does not support variant type, the main trick is to use a message 
 * have multiple optional sub-messages, and an id to identify which is the real 
 * sub-message of the message.
 */

syntax = "proto2";

package trace_format;

enum architecture_t
{
  X86    = 0;
  X86_64 = 1;
}

enum typeid_address_t
{
  Bit32 = 0;
  Bit64 = 1;
}

enum value_address_t
{
  optional uint32 value_32 = 0;
  optional uint64 value_64 = 1;
}

message address_t
{
  required typeid_address_t typeid = 0;
  required value_address_t value = 1;
}

/* register = (name, value) */

message register_t 
{
  required string name     = 1;
  required address_t value = 2;
}

/* memory = (address, value) */

message memory_t
{
  required address_t address = 1;
  required address_t value   = 2;
}

/* call = (address, name, is traced) */

enum typeid_con_info_t
{
	REGREAD  = 0;
	REGWRITE = 1;
	MEMLOAD  = 2;
	MEMSTORE = 3;
	// COMMENT       = 0xFF;
}

message value_con_info_t
{
  optional memory_t load_memory = 0;

}
 
message con_info_t
{
  required typeid_con_info_t typeid  = 0;
  optional register_t read_register  = 1;
  optional register_t write_register = 2;
  optional memory_t load_memory      = 3;
  optional memory_t store_memory     = 4;
  // optional bytes reserved_comment    = 10;
}

/* instruction = (thread_id, address, opcode, concrete_info*) */

message instruction_t
{
  required uint32 thread_id         = 0;
  required address_t address        = 1;
  required bytes opcode             = 2;
  repeated con_info_t concrete_info = 3;
  required string disassemble       = 4;
}

/* body = (metadata|instruction) */

// enum typeid_body_t
// {
// 	METADATA    = 0x0;
// 	INSTRUCTION = 0x1;
// }

// message body_t
// {
//   required typeid_body_t typeid      = 1;
//   optional metadata_t metadata       = 2;
//   optional instruction_t instruction = 3;
// }

// message chunk_t
// {
//   repeated body_t body = 1;
// }

/* header = (architecture, address size) */

message header_t
{
  required architecture_t architecture   = 0;
  required typeid_address_t address_size = 1;
}

message chunk_t
{
  repeated instruction_t instructions = 0
}


/* trace = (header, body*) */

// message trace_t
// {
// 	required header_t header = 0;
// 	repeated body_t body     = 1;
// }
