// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace_with_chunk.proto

#ifndef PROTOBUF_trace_5fwith_5fchunk_2eproto__INCLUDED
#define PROTOBUF_trace_5fwith_5fchunk_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace trace_format {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

class address_t;
class chunk_t;
class concrete_info_t;
class header_t;
class instruction_t;
class memory_t;
class register_t;

enum architecture_t {
  X86 = 0,
  X86_64 = 1,
  architecture_t_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  architecture_t_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool architecture_t_IsValid(int value);
const architecture_t architecture_t_MIN = X86;
const architecture_t architecture_t_MAX = X86_64;
const int architecture_t_ARRAYSIZE = architecture_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* architecture_t_descriptor();
inline const ::std::string& architecture_t_Name(architecture_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    architecture_t_descriptor(), value);
}
inline bool architecture_t_Parse(
    const ::std::string& name, architecture_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<architecture_t>(
    architecture_t_descriptor(), name, value);
}
// ===================================================================

class address_t : public ::google::protobuf::Message {
 public:
  address_t();
  virtual ~address_t();

  address_t(const address_t& from);

  inline address_t& operator=(const address_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const address_t& default_instance();

  enum ValueCase {
    kValue32 = 1,
    kValue64 = 2,
    VALUE_NOT_SET = 0,
  };

  void Swap(address_t* other);

  // implements Message ----------------------------------------------

  inline address_t* New() const { return New(NULL); }

  address_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const address_t& from);
  void MergeFrom(const address_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(address_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 value_32 = 1;
  private:
  bool has_value_32() const;
  public:
  void clear_value_32();
  static const int kValue32FieldNumber = 1;
  ::google::protobuf::uint32 value_32() const;
  void set_value_32(::google::protobuf::uint32 value);

  // optional uint64 value_64 = 2;
  private:
  bool has_value_64() const;
  public:
  void clear_value_64();
  static const int kValue64FieldNumber = 2;
  ::google::protobuf::uint64 value_64() const;
  void set_value_64(::google::protobuf::uint64 value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:trace_format.address_t)
 private:
  inline void set_has_value_32();
  inline void set_has_value_64();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::uint32 value_32_;
    ::google::protobuf::uint64 value_64_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static address_t* default_instance_;
};
// -------------------------------------------------------------------

class register_t : public ::google::protobuf::Message {
 public:
  register_t();
  virtual ~register_t();

  register_t(const register_t& from);

  inline register_t& operator=(const register_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const register_t& default_instance();

  void Swap(register_t* other);

  // implements Message ----------------------------------------------

  inline register_t* New() const { return New(NULL); }

  register_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const register_t& from);
  void MergeFrom(const register_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(register_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .trace_format.address_t value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::trace_format::address_t& value() const;
  ::trace_format::address_t* mutable_value();
  ::trace_format::address_t* release_value();
  void set_allocated_value(::trace_format::address_t* value);

  // @@protoc_insertion_point(class_scope:trace_format.register_t)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::trace_format::address_t* value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static register_t* default_instance_;
};
// -------------------------------------------------------------------

class memory_t : public ::google::protobuf::Message {
 public:
  memory_t();
  virtual ~memory_t();

  memory_t(const memory_t& from);

  inline memory_t& operator=(const memory_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memory_t& default_instance();

  void Swap(memory_t* other);

  // implements Message ----------------------------------------------

  inline memory_t* New() const { return New(NULL); }

  memory_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const memory_t& from);
  void MergeFrom(const memory_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(memory_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trace_format.address_t address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::trace_format::address_t& address() const;
  ::trace_format::address_t* mutable_address();
  ::trace_format::address_t* release_address();
  void set_allocated_address(::trace_format::address_t* address);

  // optional uint32 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:trace_format.memory_t)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::trace_format::address_t* address_;
  ::google::protobuf::uint32 value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static memory_t* default_instance_;
};
// -------------------------------------------------------------------

class concrete_info_t : public ::google::protobuf::Message {
 public:
  concrete_info_t();
  virtual ~concrete_info_t();

  concrete_info_t(const concrete_info_t& from);

  inline concrete_info_t& operator=(const concrete_info_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const concrete_info_t& default_instance();

  enum ValueCase {
    kReadRegister = 1,
    kWriteRegister = 2,
    kLoadMemory = 3,
    kStoreMemory = 4,
    VALUE_NOT_SET = 0,
  };

  void Swap(concrete_info_t* other);

  // implements Message ----------------------------------------------

  inline concrete_info_t* New() const { return New(NULL); }

  concrete_info_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const concrete_info_t& from);
  void MergeFrom(const concrete_info_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(concrete_info_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trace_format.register_t read_register = 1;
  bool has_read_register() const;
  void clear_read_register();
  static const int kReadRegisterFieldNumber = 1;
  const ::trace_format::register_t& read_register() const;
  ::trace_format::register_t* mutable_read_register();
  ::trace_format::register_t* release_read_register();
  void set_allocated_read_register(::trace_format::register_t* read_register);

  // optional .trace_format.register_t write_register = 2;
  bool has_write_register() const;
  void clear_write_register();
  static const int kWriteRegisterFieldNumber = 2;
  const ::trace_format::register_t& write_register() const;
  ::trace_format::register_t* mutable_write_register();
  ::trace_format::register_t* release_write_register();
  void set_allocated_write_register(::trace_format::register_t* write_register);

  // optional .trace_format.memory_t load_memory = 3;
  bool has_load_memory() const;
  void clear_load_memory();
  static const int kLoadMemoryFieldNumber = 3;
  const ::trace_format::memory_t& load_memory() const;
  ::trace_format::memory_t* mutable_load_memory();
  ::trace_format::memory_t* release_load_memory();
  void set_allocated_load_memory(::trace_format::memory_t* load_memory);

  // optional .trace_format.memory_t store_memory = 4;
  bool has_store_memory() const;
  void clear_store_memory();
  static const int kStoreMemoryFieldNumber = 4;
  const ::trace_format::memory_t& store_memory() const;
  ::trace_format::memory_t* mutable_store_memory();
  ::trace_format::memory_t* release_store_memory();
  void set_allocated_store_memory(::trace_format::memory_t* store_memory);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:trace_format.concrete_info_t)
 private:
  inline void set_has_read_register();
  inline void set_has_write_register();
  inline void set_has_load_memory();
  inline void set_has_store_memory();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union ValueUnion {
    ValueUnion() {}
    ::trace_format::register_t* read_register_;
    ::trace_format::register_t* write_register_;
    ::trace_format::memory_t* load_memory_;
    ::trace_format::memory_t* store_memory_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static concrete_info_t* default_instance_;
};
// -------------------------------------------------------------------

class instruction_t : public ::google::protobuf::Message {
 public:
  instruction_t();
  virtual ~instruction_t();

  instruction_t(const instruction_t& from);

  inline instruction_t& operator=(const instruction_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const instruction_t& default_instance();

  void Swap(instruction_t* other);

  // implements Message ----------------------------------------------

  inline instruction_t* New() const { return New(NULL); }

  instruction_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const instruction_t& from);
  void MergeFrom(const instruction_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(instruction_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 thread_id = 1;
  void clear_thread_id();
  static const int kThreadIdFieldNumber = 1;
  ::google::protobuf::uint32 thread_id() const;
  void set_thread_id(::google::protobuf::uint32 value);

  // optional .trace_format.address_t address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::trace_format::address_t& address() const;
  ::trace_format::address_t* mutable_address();
  ::trace_format::address_t* release_address();
  void set_allocated_address(::trace_format::address_t* address);

  // optional bytes opcode = 3;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 3;
  const ::std::string& opcode() const;
  void set_opcode(const ::std::string& value);
  void set_opcode(const char* value);
  void set_opcode(const void* value, size_t size);
  ::std::string* mutable_opcode();
  ::std::string* release_opcode();
  void set_allocated_opcode(::std::string* opcode);

  // optional string disassemble = 4;
  void clear_disassemble();
  static const int kDisassembleFieldNumber = 4;
  const ::std::string& disassemble() const;
  void set_disassemble(const ::std::string& value);
  void set_disassemble(const char* value);
  void set_disassemble(const char* value, size_t size);
  ::std::string* mutable_disassemble();
  ::std::string* release_disassemble();
  void set_allocated_disassemble(::std::string* disassemble);

  // repeated .trace_format.concrete_info_t c_info = 5;
  int c_info_size() const;
  void clear_c_info();
  static const int kCInfoFieldNumber = 5;
  const ::trace_format::concrete_info_t& c_info(int index) const;
  ::trace_format::concrete_info_t* mutable_c_info(int index);
  ::trace_format::concrete_info_t* add_c_info();
  ::google::protobuf::RepeatedPtrField< ::trace_format::concrete_info_t >*
      mutable_c_info();
  const ::google::protobuf::RepeatedPtrField< ::trace_format::concrete_info_t >&
      c_info() const;

  // @@protoc_insertion_point(class_scope:trace_format.instruction_t)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::trace_format::address_t* address_;
  ::google::protobuf::internal::ArenaStringPtr opcode_;
  ::google::protobuf::internal::ArenaStringPtr disassemble_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::concrete_info_t > c_info_;
  ::google::protobuf::uint32 thread_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static instruction_t* default_instance_;
};
// -------------------------------------------------------------------

class header_t : public ::google::protobuf::Message {
 public:
  header_t();
  virtual ~header_t();

  header_t(const header_t& from);

  inline header_t& operator=(const header_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const header_t& default_instance();

  void Swap(header_t* other);

  // implements Message ----------------------------------------------

  inline header_t* New() const { return New(NULL); }

  header_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const header_t& from);
  void MergeFrom(const header_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(header_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .trace_format.architecture_t architecture = 1;
  void clear_architecture();
  static const int kArchitectureFieldNumber = 1;
  ::trace_format::architecture_t architecture() const;
  void set_architecture(::trace_format::architecture_t value);

  // @@protoc_insertion_point(class_scope:trace_format.header_t)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int architecture_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static header_t* default_instance_;
};
// -------------------------------------------------------------------

class chunk_t : public ::google::protobuf::Message {
 public:
  chunk_t();
  virtual ~chunk_t();

  chunk_t(const chunk_t& from);

  inline chunk_t& operator=(const chunk_t& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chunk_t& default_instance();

  void Swap(chunk_t* other);

  // implements Message ----------------------------------------------

  inline chunk_t* New() const { return New(NULL); }

  chunk_t* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chunk_t& from);
  void MergeFrom(const chunk_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(chunk_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .trace_format.instruction_t instructions = 1;
  int instructions_size() const;
  void clear_instructions();
  static const int kInstructionsFieldNumber = 1;
  const ::trace_format::instruction_t& instructions(int index) const;
  ::trace_format::instruction_t* mutable_instructions(int index);
  ::trace_format::instruction_t* add_instructions();
  ::google::protobuf::RepeatedPtrField< ::trace_format::instruction_t >*
      mutable_instructions();
  const ::google::protobuf::RepeatedPtrField< ::trace_format::instruction_t >&
      instructions() const;

  // @@protoc_insertion_point(class_scope:trace_format.chunk_t)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::instruction_t > instructions_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static chunk_t* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// address_t

// optional uint32 value_32 = 1;
inline bool address_t::has_value_32() const {
  return value_case() == kValue32;
}
inline void address_t::set_has_value_32() {
  _oneof_case_[0] = kValue32;
}
inline void address_t::clear_value_32() {
  if (has_value_32()) {
    value_.value_32_ = 0u;
    clear_has_value();
  }
}
inline ::google::protobuf::uint32 address_t::value_32() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_32)
  if (has_value_32()) {
    return value_.value_32_;
  }
  return 0u;
}
inline void address_t::set_value_32(::google::protobuf::uint32 value) {
  if (!has_value_32()) {
    clear_value();
    set_has_value_32();
  }
  value_.value_32_ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_32)
}

// optional uint64 value_64 = 2;
inline bool address_t::has_value_64() const {
  return value_case() == kValue64;
}
inline void address_t::set_has_value_64() {
  _oneof_case_[0] = kValue64;
}
inline void address_t::clear_value_64() {
  if (has_value_64()) {
    value_.value_64_ = GOOGLE_ULONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::uint64 address_t::value_64() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_64)
  if (has_value_64()) {
    return value_.value_64_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void address_t::set_value_64(::google::protobuf::uint64 value) {
  if (!has_value_64()) {
    clear_value();
    set_has_value_64();
  }
  value_.value_64_ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_64)
}

inline bool address_t::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void address_t::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline address_t::ValueCase address_t::value_case() const {
  return address_t::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// register_t

// optional string name = 1;
inline void register_t::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& register_t::name() const {
  // @@protoc_insertion_point(field_get:trace_format.register_t.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void register_t::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:trace_format.register_t.name)
}
inline void register_t::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trace_format.register_t.name)
}
inline void register_t::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trace_format.register_t.name)
}
inline ::std::string* register_t::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:trace_format.register_t.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* register_t::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void register_t::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:trace_format.register_t.name)
}

// optional .trace_format.address_t value = 2;
inline bool register_t::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void register_t::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::trace_format::address_t& register_t::value() const {
  // @@protoc_insertion_point(field_get:trace_format.register_t.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::trace_format::address_t* register_t::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::trace_format::address_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.register_t.value)
  return value_;
}
inline ::trace_format::address_t* register_t::release_value() {
  
  ::trace_format::address_t* temp = value_;
  value_ = NULL;
  return temp;
}
inline void register_t::set_allocated_value(::trace_format::address_t* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.register_t.value)
}

// -------------------------------------------------------------------

// memory_t

// optional .trace_format.address_t address = 1;
inline bool memory_t::has_address() const {
  return !_is_default_instance_ && address_ != NULL;
}
inline void memory_t::clear_address() {
  if (GetArenaNoVirtual() == NULL && address_ != NULL) delete address_;
  address_ = NULL;
}
inline const ::trace_format::address_t& memory_t::address() const {
  // @@protoc_insertion_point(field_get:trace_format.memory_t.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::trace_format::address_t* memory_t::mutable_address() {
  
  if (address_ == NULL) {
    address_ = new ::trace_format::address_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.memory_t.address)
  return address_;
}
inline ::trace_format::address_t* memory_t::release_address() {
  
  ::trace_format::address_t* temp = address_;
  address_ = NULL;
  return temp;
}
inline void memory_t::set_allocated_address(::trace_format::address_t* address) {
  delete address_;
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.memory_t.address)
}

// optional uint32 value = 2;
inline void memory_t::clear_value() {
  value_ = 0u;
}
inline ::google::protobuf::uint32 memory_t::value() const {
  // @@protoc_insertion_point(field_get:trace_format.memory_t.value)
  return value_;
}
inline void memory_t::set_value(::google::protobuf::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:trace_format.memory_t.value)
}

// -------------------------------------------------------------------

// concrete_info_t

// optional .trace_format.register_t read_register = 1;
inline bool concrete_info_t::has_read_register() const {
  return value_case() == kReadRegister;
}
inline void concrete_info_t::set_has_read_register() {
  _oneof_case_[0] = kReadRegister;
}
inline void concrete_info_t::clear_read_register() {
  if (has_read_register()) {
    delete value_.read_register_;
    clear_has_value();
  }
}
inline  const ::trace_format::register_t& concrete_info_t::read_register() const {
  // @@protoc_insertion_point(field_get:trace_format.concrete_info_t.read_register)
  return has_read_register()
      ? *value_.read_register_
      : ::trace_format::register_t::default_instance();
}
inline ::trace_format::register_t* concrete_info_t::mutable_read_register() {
  if (!has_read_register()) {
    clear_value();
    set_has_read_register();
    value_.read_register_ = new ::trace_format::register_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.concrete_info_t.read_register)
  return value_.read_register_;
}
inline ::trace_format::register_t* concrete_info_t::release_read_register() {
  if (has_read_register()) {
    clear_has_value();
    ::trace_format::register_t* temp = value_.read_register_;
    value_.read_register_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void concrete_info_t::set_allocated_read_register(::trace_format::register_t* read_register) {
  clear_value();
  if (read_register) {
    set_has_read_register();
    value_.read_register_ = read_register;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.concrete_info_t.read_register)
}

// optional .trace_format.register_t write_register = 2;
inline bool concrete_info_t::has_write_register() const {
  return value_case() == kWriteRegister;
}
inline void concrete_info_t::set_has_write_register() {
  _oneof_case_[0] = kWriteRegister;
}
inline void concrete_info_t::clear_write_register() {
  if (has_write_register()) {
    delete value_.write_register_;
    clear_has_value();
  }
}
inline  const ::trace_format::register_t& concrete_info_t::write_register() const {
  // @@protoc_insertion_point(field_get:trace_format.concrete_info_t.write_register)
  return has_write_register()
      ? *value_.write_register_
      : ::trace_format::register_t::default_instance();
}
inline ::trace_format::register_t* concrete_info_t::mutable_write_register() {
  if (!has_write_register()) {
    clear_value();
    set_has_write_register();
    value_.write_register_ = new ::trace_format::register_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.concrete_info_t.write_register)
  return value_.write_register_;
}
inline ::trace_format::register_t* concrete_info_t::release_write_register() {
  if (has_write_register()) {
    clear_has_value();
    ::trace_format::register_t* temp = value_.write_register_;
    value_.write_register_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void concrete_info_t::set_allocated_write_register(::trace_format::register_t* write_register) {
  clear_value();
  if (write_register) {
    set_has_write_register();
    value_.write_register_ = write_register;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.concrete_info_t.write_register)
}

// optional .trace_format.memory_t load_memory = 3;
inline bool concrete_info_t::has_load_memory() const {
  return value_case() == kLoadMemory;
}
inline void concrete_info_t::set_has_load_memory() {
  _oneof_case_[0] = kLoadMemory;
}
inline void concrete_info_t::clear_load_memory() {
  if (has_load_memory()) {
    delete value_.load_memory_;
    clear_has_value();
  }
}
inline  const ::trace_format::memory_t& concrete_info_t::load_memory() const {
  // @@protoc_insertion_point(field_get:trace_format.concrete_info_t.load_memory)
  return has_load_memory()
      ? *value_.load_memory_
      : ::trace_format::memory_t::default_instance();
}
inline ::trace_format::memory_t* concrete_info_t::mutable_load_memory() {
  if (!has_load_memory()) {
    clear_value();
    set_has_load_memory();
    value_.load_memory_ = new ::trace_format::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.concrete_info_t.load_memory)
  return value_.load_memory_;
}
inline ::trace_format::memory_t* concrete_info_t::release_load_memory() {
  if (has_load_memory()) {
    clear_has_value();
    ::trace_format::memory_t* temp = value_.load_memory_;
    value_.load_memory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void concrete_info_t::set_allocated_load_memory(::trace_format::memory_t* load_memory) {
  clear_value();
  if (load_memory) {
    set_has_load_memory();
    value_.load_memory_ = load_memory;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.concrete_info_t.load_memory)
}

// optional .trace_format.memory_t store_memory = 4;
inline bool concrete_info_t::has_store_memory() const {
  return value_case() == kStoreMemory;
}
inline void concrete_info_t::set_has_store_memory() {
  _oneof_case_[0] = kStoreMemory;
}
inline void concrete_info_t::clear_store_memory() {
  if (has_store_memory()) {
    delete value_.store_memory_;
    clear_has_value();
  }
}
inline  const ::trace_format::memory_t& concrete_info_t::store_memory() const {
  // @@protoc_insertion_point(field_get:trace_format.concrete_info_t.store_memory)
  return has_store_memory()
      ? *value_.store_memory_
      : ::trace_format::memory_t::default_instance();
}
inline ::trace_format::memory_t* concrete_info_t::mutable_store_memory() {
  if (!has_store_memory()) {
    clear_value();
    set_has_store_memory();
    value_.store_memory_ = new ::trace_format::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.concrete_info_t.store_memory)
  return value_.store_memory_;
}
inline ::trace_format::memory_t* concrete_info_t::release_store_memory() {
  if (has_store_memory()) {
    clear_has_value();
    ::trace_format::memory_t* temp = value_.store_memory_;
    value_.store_memory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void concrete_info_t::set_allocated_store_memory(::trace_format::memory_t* store_memory) {
  clear_value();
  if (store_memory) {
    set_has_store_memory();
    value_.store_memory_ = store_memory;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.concrete_info_t.store_memory)
}

inline bool concrete_info_t::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void concrete_info_t::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline concrete_info_t::ValueCase concrete_info_t::value_case() const {
  return concrete_info_t::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// instruction_t

// optional uint32 thread_id = 1;
inline void instruction_t::clear_thread_id() {
  thread_id_ = 0u;
}
inline ::google::protobuf::uint32 instruction_t::thread_id() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.thread_id)
  return thread_id_;
}
inline void instruction_t::set_thread_id(::google::protobuf::uint32 value) {
  
  thread_id_ = value;
  // @@protoc_insertion_point(field_set:trace_format.instruction_t.thread_id)
}

// optional .trace_format.address_t address = 2;
inline bool instruction_t::has_address() const {
  return !_is_default_instance_ && address_ != NULL;
}
inline void instruction_t::clear_address() {
  if (GetArenaNoVirtual() == NULL && address_ != NULL) delete address_;
  address_ = NULL;
}
inline const ::trace_format::address_t& instruction_t::address() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::trace_format::address_t* instruction_t::mutable_address() {
  
  if (address_ == NULL) {
    address_ = new ::trace_format::address_t;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.address)
  return address_;
}
inline ::trace_format::address_t* instruction_t::release_address() {
  
  ::trace_format::address_t* temp = address_;
  address_ = NULL;
  return temp;
}
inline void instruction_t::set_allocated_address(::trace_format::address_t* address) {
  delete address_;
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.instruction_t.address)
}

// optional bytes opcode = 3;
inline void instruction_t::clear_opcode() {
  opcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& instruction_t::opcode() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.opcode)
  return opcode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void instruction_t::set_opcode(const ::std::string& value) {
  
  opcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:trace_format.instruction_t.opcode)
}
inline void instruction_t::set_opcode(const char* value) {
  
  opcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trace_format.instruction_t.opcode)
}
inline void instruction_t::set_opcode(const void* value, size_t size) {
  
  opcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trace_format.instruction_t.opcode)
}
inline ::std::string* instruction_t::mutable_opcode() {
  
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.opcode)
  return opcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* instruction_t::release_opcode() {
  
  return opcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void instruction_t::set_allocated_opcode(::std::string* opcode) {
  if (opcode != NULL) {
    
  } else {
    
  }
  opcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opcode);
  // @@protoc_insertion_point(field_set_allocated:trace_format.instruction_t.opcode)
}

// optional string disassemble = 4;
inline void instruction_t::clear_disassemble() {
  disassemble_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& instruction_t::disassemble() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.disassemble)
  return disassemble_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void instruction_t::set_disassemble(const ::std::string& value) {
  
  disassemble_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:trace_format.instruction_t.disassemble)
}
inline void instruction_t::set_disassemble(const char* value) {
  
  disassemble_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trace_format.instruction_t.disassemble)
}
inline void instruction_t::set_disassemble(const char* value, size_t size) {
  
  disassemble_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trace_format.instruction_t.disassemble)
}
inline ::std::string* instruction_t::mutable_disassemble() {
  
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.disassemble)
  return disassemble_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* instruction_t::release_disassemble() {
  
  return disassemble_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void instruction_t::set_allocated_disassemble(::std::string* disassemble) {
  if (disassemble != NULL) {
    
  } else {
    
  }
  disassemble_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), disassemble);
  // @@protoc_insertion_point(field_set_allocated:trace_format.instruction_t.disassemble)
}

// repeated .trace_format.concrete_info_t c_info = 5;
inline int instruction_t::c_info_size() const {
  return c_info_.size();
}
inline void instruction_t::clear_c_info() {
  c_info_.Clear();
}
inline const ::trace_format::concrete_info_t& instruction_t::c_info(int index) const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.c_info)
  return c_info_.Get(index);
}
inline ::trace_format::concrete_info_t* instruction_t::mutable_c_info(int index) {
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.c_info)
  return c_info_.Mutable(index);
}
inline ::trace_format::concrete_info_t* instruction_t::add_c_info() {
  // @@protoc_insertion_point(field_add:trace_format.instruction_t.c_info)
  return c_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::concrete_info_t >*
instruction_t::mutable_c_info() {
  // @@protoc_insertion_point(field_mutable_list:trace_format.instruction_t.c_info)
  return &c_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::concrete_info_t >&
instruction_t::c_info() const {
  // @@protoc_insertion_point(field_list:trace_format.instruction_t.c_info)
  return c_info_;
}

// -------------------------------------------------------------------

// header_t

// optional .trace_format.architecture_t architecture = 1;
inline void header_t::clear_architecture() {
  architecture_ = 0;
}
inline ::trace_format::architecture_t header_t::architecture() const {
  // @@protoc_insertion_point(field_get:trace_format.header_t.architecture)
  return static_cast< ::trace_format::architecture_t >(architecture_);
}
inline void header_t::set_architecture(::trace_format::architecture_t value) {
  
  architecture_ = value;
  // @@protoc_insertion_point(field_set:trace_format.header_t.architecture)
}

// -------------------------------------------------------------------

// chunk_t

// repeated .trace_format.instruction_t instructions = 1;
inline int chunk_t::instructions_size() const {
  return instructions_.size();
}
inline void chunk_t::clear_instructions() {
  instructions_.Clear();
}
inline const ::trace_format::instruction_t& chunk_t::instructions(int index) const {
  // @@protoc_insertion_point(field_get:trace_format.chunk_t.instructions)
  return instructions_.Get(index);
}
inline ::trace_format::instruction_t* chunk_t::mutable_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:trace_format.chunk_t.instructions)
  return instructions_.Mutable(index);
}
inline ::trace_format::instruction_t* chunk_t::add_instructions() {
  // @@protoc_insertion_point(field_add:trace_format.chunk_t.instructions)
  return instructions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::instruction_t >*
chunk_t::mutable_instructions() {
  // @@protoc_insertion_point(field_mutable_list:trace_format.chunk_t.instructions)
  return &instructions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::instruction_t >&
chunk_t::instructions() const {
  // @@protoc_insertion_point(field_list:trace_format.chunk_t.instructions)
  return instructions_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trace_format

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::trace_format::architecture_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::architecture_t>() {
  return ::trace_format::architecture_t_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trace_5fwith_5fchunk_2eproto__INCLUDED
