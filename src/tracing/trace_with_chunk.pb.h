// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace_with_chunk.proto

#ifndef PROTOBUF_trace_5fwith_5fchunk_2eproto__INCLUDED
#define PROTOBUF_trace_5fwith_5fchunk_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace trace_format {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

class address_t;
class header_t;
class module_t;
class exception_t;
class metadata_t;
class register_t;
class memory_t;
class ins_con_info_t;
class instruction_t;
class body_t;
class chunk_t;
class trace_t;

enum architecture_t {
  X86 = 0,
  X86_64 = 1
};
bool architecture_t_IsValid(int value);
const architecture_t architecture_t_MIN = X86;
const architecture_t architecture_t_MAX = X86_64;
const int architecture_t_ARRAYSIZE = architecture_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* architecture_t_descriptor();
inline const ::std::string& architecture_t_Name(architecture_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    architecture_t_descriptor(), value);
}
inline bool architecture_t_Parse(
    const ::std::string& name, architecture_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<architecture_t>(
    architecture_t_descriptor(), name, value);
}
enum typeid_address_t {
  BIT8 = 0,
  BIT16 = 1,
  BIT32 = 2,
  BIT64 = 3,
  BIT128 = 4
};
bool typeid_address_t_IsValid(int value);
const typeid_address_t typeid_address_t_MIN = BIT8;
const typeid_address_t typeid_address_t_MAX = BIT128;
const int typeid_address_t_ARRAYSIZE = typeid_address_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_address_t_descriptor();
inline const ::std::string& typeid_address_t_Name(typeid_address_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_address_t_descriptor(), value);
}
inline bool typeid_address_t_Parse(
    const ::std::string& name, typeid_address_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_address_t>(
    typeid_address_t_descriptor(), name, value);
}
enum typeid_metadata_t {
  EXCEPTION_TYPE = 0,
  MODULE_TYPE = 1,
  WAVE_TYPE = 2
};
bool typeid_metadata_t_IsValid(int value);
const typeid_metadata_t typeid_metadata_t_MIN = EXCEPTION_TYPE;
const typeid_metadata_t typeid_metadata_t_MAX = WAVE_TYPE;
const int typeid_metadata_t_ARRAYSIZE = typeid_metadata_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_metadata_t_descriptor();
inline const ::std::string& typeid_metadata_t_Name(typeid_metadata_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_metadata_t_descriptor(), value);
}
inline bool typeid_metadata_t_Parse(
    const ::std::string& name, typeid_metadata_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_metadata_t>(
    typeid_metadata_t_descriptor(), name, value);
}
enum typeid_con_info_t {
  REGREAD = 0,
  REGWRITE = 1,
  MEMLOAD = 2,
  MEMSTORE = 3,
  COMMENT = 255
};
bool typeid_con_info_t_IsValid(int value);
const typeid_con_info_t typeid_con_info_t_MIN = REGREAD;
const typeid_con_info_t typeid_con_info_t_MAX = COMMENT;
const int typeid_con_info_t_ARRAYSIZE = typeid_con_info_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_con_info_t_descriptor();
inline const ::std::string& typeid_con_info_t_Name(typeid_con_info_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_con_info_t_descriptor(), value);
}
inline bool typeid_con_info_t_Parse(
    const ::std::string& name, typeid_con_info_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_con_info_t>(
    typeid_con_info_t_descriptor(), name, value);
}
enum typeid_body_t {
  METADATA = 0,
  INSTRUCTION = 1
};
bool typeid_body_t_IsValid(int value);
const typeid_body_t typeid_body_t_MIN = METADATA;
const typeid_body_t typeid_body_t_MAX = INSTRUCTION;
const int typeid_body_t_ARRAYSIZE = typeid_body_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_body_t_descriptor();
inline const ::std::string& typeid_body_t_Name(typeid_body_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_body_t_descriptor(), value);
}
inline bool typeid_body_t_Parse(
    const ::std::string& name, typeid_body_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_body_t>(
    typeid_body_t_descriptor(), name, value);
}
// ===================================================================

class address_t : public ::google::protobuf::Message {
 public:
  address_t();
  virtual ~address_t();

  address_t(const address_t& from);

  inline address_t& operator=(const address_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const address_t& default_instance();

  void Swap(address_t* other);

  // implements Message ----------------------------------------------

  address_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const address_t& from);
  void MergeFrom(const address_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_address_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_address_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_address_t value);

  // optional uint32 value_8 = 2;
  inline bool has_value_8() const;
  inline void clear_value_8();
  static const int kValue8FieldNumber = 2;
  inline ::google::protobuf::uint32 value_8() const;
  inline void set_value_8(::google::protobuf::uint32 value);

  // optional uint32 value_16 = 3;
  inline bool has_value_16() const;
  inline void clear_value_16();
  static const int kValue16FieldNumber = 3;
  inline ::google::protobuf::uint32 value_16() const;
  inline void set_value_16(::google::protobuf::uint32 value);

  // optional uint32 value_32 = 4;
  inline bool has_value_32() const;
  inline void clear_value_32();
  static const int kValue32FieldNumber = 4;
  inline ::google::protobuf::uint32 value_32() const;
  inline void set_value_32(::google::protobuf::uint32 value);

  // optional uint64 value_64 = 5;
  inline bool has_value_64() const;
  inline void clear_value_64();
  static const int kValue64FieldNumber = 5;
  inline ::google::protobuf::uint64 value_64() const;
  inline void set_value_64(::google::protobuf::uint64 value);

  // optional bytes value_128 = 6;
  inline bool has_value_128() const;
  inline void clear_value_128();
  static const int kValue128FieldNumber = 6;
  inline const ::std::string& value_128() const;
  inline void set_value_128(const ::std::string& value);
  inline void set_value_128(const char* value);
  inline void set_value_128(const void* value, size_t size);
  inline ::std::string* mutable_value_128();
  inline ::std::string* release_value_128();
  inline void set_allocated_value_128(::std::string* value_128);

  // @@protoc_insertion_point(class_scope:trace_format.address_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_value_8();
  inline void clear_has_value_8();
  inline void set_has_value_16();
  inline void clear_has_value_16();
  inline void set_has_value_32();
  inline void clear_has_value_32();
  inline void set_has_value_64();
  inline void clear_has_value_64();
  inline void set_has_value_128();
  inline void clear_has_value_128();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int typeid__;
  ::google::protobuf::uint32 value_8_;
  ::google::protobuf::uint32 value_16_;
  ::google::protobuf::uint32 value_32_;
  ::google::protobuf::uint64 value_64_;
  ::std::string* value_128_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static address_t* default_instance_;
};
// -------------------------------------------------------------------

class header_t : public ::google::protobuf::Message {
 public:
  header_t();
  virtual ~header_t();

  header_t(const header_t& from);

  inline header_t& operator=(const header_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const header_t& default_instance();

  void Swap(header_t* other);

  // implements Message ----------------------------------------------

  header_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const header_t& from);
  void MergeFrom(const header_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.architecture_t architecture = 1;
  inline bool has_architecture() const;
  inline void clear_architecture();
  static const int kArchitectureFieldNumber = 1;
  inline ::trace_format::architecture_t architecture() const;
  inline void set_architecture(::trace_format::architecture_t value);

  // required .trace_format.typeid_address_t address_size = 2;
  inline bool has_address_size() const;
  inline void clear_address_size();
  static const int kAddressSizeFieldNumber = 2;
  inline ::trace_format::typeid_address_t address_size() const;
  inline void set_address_size(::trace_format::typeid_address_t value);

  // @@protoc_insertion_point(class_scope:trace_format.header_t)
 private:
  inline void set_has_architecture();
  inline void clear_has_architecture();
  inline void set_has_address_size();
  inline void clear_has_address_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int architecture_;
  int address_size_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static header_t* default_instance_;
};
// -------------------------------------------------------------------

class module_t : public ::google::protobuf::Message {
 public:
  module_t();
  virtual ~module_t();

  module_t(const module_t& from);

  inline module_t& operator=(const module_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const module_t& default_instance();

  void Swap(module_t* other);

  // implements Message ----------------------------------------------

  module_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const module_t& from);
  void MergeFrom(const module_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:trace_format.module_t)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static module_t* default_instance_;
};
// -------------------------------------------------------------------

class exception_t : public ::google::protobuf::Message {
 public:
  exception_t();
  virtual ~exception_t();

  exception_t(const exception_t& from);

  inline exception_t& operator=(const exception_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exception_t& default_instance();

  void Swap(exception_t* other);

  // implements Message ----------------------------------------------

  exception_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exception_t& from);
  void MergeFrom(const exception_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type_exception = 1;
  inline bool has_type_exception() const;
  inline void clear_type_exception();
  static const int kTypeExceptionFieldNumber = 1;
  inline ::google::protobuf::uint32 type_exception() const;
  inline void set_type_exception(::google::protobuf::uint32 value);

  // required .trace_format.address_t handler = 2;
  inline bool has_handler() const;
  inline void clear_handler();
  static const int kHandlerFieldNumber = 2;
  inline const ::trace_format::address_t& handler() const;
  inline ::trace_format::address_t* mutable_handler();
  inline ::trace_format::address_t* release_handler();
  inline void set_allocated_handler(::trace_format::address_t* handler);

  // @@protoc_insertion_point(class_scope:trace_format.exception_t)
 private:
  inline void set_has_type_exception();
  inline void clear_has_type_exception();
  inline void set_has_handler();
  inline void clear_has_handler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::address_t* handler_;
  ::google::protobuf::uint32 type_exception_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static exception_t* default_instance_;
};
// -------------------------------------------------------------------

class metadata_t : public ::google::protobuf::Message {
 public:
  metadata_t();
  virtual ~metadata_t();

  metadata_t(const metadata_t& from);

  inline metadata_t& operator=(const metadata_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const metadata_t& default_instance();

  void Swap(metadata_t* other);

  // implements Message ----------------------------------------------

  metadata_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const metadata_t& from);
  void MergeFrom(const metadata_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_metadata_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_metadata_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_metadata_t value);

  // optional .trace_format.module_t module_metadata = 2;
  inline bool has_module_metadata() const;
  inline void clear_module_metadata();
  static const int kModuleMetadataFieldNumber = 2;
  inline const ::trace_format::module_t& module_metadata() const;
  inline ::trace_format::module_t* mutable_module_metadata();
  inline ::trace_format::module_t* release_module_metadata();
  inline void set_allocated_module_metadata(::trace_format::module_t* module_metadata);

  // optional .trace_format.exception_t exception_metadata = 3;
  inline bool has_exception_metadata() const;
  inline void clear_exception_metadata();
  static const int kExceptionMetadataFieldNumber = 3;
  inline const ::trace_format::exception_t& exception_metadata() const;
  inline ::trace_format::exception_t* mutable_exception_metadata();
  inline ::trace_format::exception_t* release_exception_metadata();
  inline void set_allocated_exception_metadata(::trace_format::exception_t* exception_metadata);

  // optional uint32 wave_metadata = 4;
  inline bool has_wave_metadata() const;
  inline void clear_wave_metadata();
  static const int kWaveMetadataFieldNumber = 4;
  inline ::google::protobuf::uint32 wave_metadata() const;
  inline void set_wave_metadata(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:trace_format.metadata_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_module_metadata();
  inline void clear_has_module_metadata();
  inline void set_has_exception_metadata();
  inline void clear_has_exception_metadata();
  inline void set_has_wave_metadata();
  inline void clear_has_wave_metadata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::module_t* module_metadata_;
  int typeid__;
  ::google::protobuf::uint32 wave_metadata_;
  ::trace_format::exception_t* exception_metadata_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static metadata_t* default_instance_;
};
// -------------------------------------------------------------------

class register_t : public ::google::protobuf::Message {
 public:
  register_t();
  virtual ~register_t();

  register_t(const register_t& from);

  inline register_t& operator=(const register_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const register_t& default_instance();

  void Swap(register_t* other);

  // implements Message ----------------------------------------------

  register_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const register_t& from);
  void MergeFrom(const register_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .trace_format.address_t value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::trace_format::address_t& value() const;
  inline ::trace_format::address_t* mutable_value();
  inline ::trace_format::address_t* release_value();
  inline void set_allocated_value(::trace_format::address_t* value);

  // @@protoc_insertion_point(class_scope:trace_format.register_t)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::trace_format::address_t* value_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static register_t* default_instance_;
};
// -------------------------------------------------------------------

class memory_t : public ::google::protobuf::Message {
 public:
  memory_t();
  virtual ~memory_t();

  memory_t(const memory_t& from);

  inline memory_t& operator=(const memory_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memory_t& default_instance();

  void Swap(memory_t* other);

  // implements Message ----------------------------------------------

  memory_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const memory_t& from);
  void MergeFrom(const memory_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.address_t address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::trace_format::address_t& address() const;
  inline ::trace_format::address_t* mutable_address();
  inline ::trace_format::address_t* release_address();
  inline void set_allocated_address(::trace_format::address_t* address);

  // required .trace_format.address_t value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::trace_format::address_t& value() const;
  inline ::trace_format::address_t* mutable_value();
  inline ::trace_format::address_t* release_value();
  inline void set_allocated_value(::trace_format::address_t* value);

  // @@protoc_insertion_point(class_scope:trace_format.memory_t)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::address_t* address_;
  ::trace_format::address_t* value_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static memory_t* default_instance_;
};
// -------------------------------------------------------------------

class ins_con_info_t : public ::google::protobuf::Message {
 public:
  ins_con_info_t();
  virtual ~ins_con_info_t();

  ins_con_info_t(const ins_con_info_t& from);

  inline ins_con_info_t& operator=(const ins_con_info_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ins_con_info_t& default_instance();

  void Swap(ins_con_info_t* other);

  // implements Message ----------------------------------------------

  ins_con_info_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ins_con_info_t& from);
  void MergeFrom(const ins_con_info_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_con_info_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_con_info_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_con_info_t value);

  // optional .trace_format.register_t read_register = 2;
  inline bool has_read_register() const;
  inline void clear_read_register();
  static const int kReadRegisterFieldNumber = 2;
  inline const ::trace_format::register_t& read_register() const;
  inline ::trace_format::register_t* mutable_read_register();
  inline ::trace_format::register_t* release_read_register();
  inline void set_allocated_read_register(::trace_format::register_t* read_register);

  // optional .trace_format.register_t write_register = 3;
  inline bool has_write_register() const;
  inline void clear_write_register();
  static const int kWriteRegisterFieldNumber = 3;
  inline const ::trace_format::register_t& write_register() const;
  inline ::trace_format::register_t* mutable_write_register();
  inline ::trace_format::register_t* release_write_register();
  inline void set_allocated_write_register(::trace_format::register_t* write_register);

  // optional .trace_format.memory_t load_memory = 4;
  inline bool has_load_memory() const;
  inline void clear_load_memory();
  static const int kLoadMemoryFieldNumber = 4;
  inline const ::trace_format::memory_t& load_memory() const;
  inline ::trace_format::memory_t* mutable_load_memory();
  inline ::trace_format::memory_t* release_load_memory();
  inline void set_allocated_load_memory(::trace_format::memory_t* load_memory);

  // optional .trace_format.memory_t store_memory = 5;
  inline bool has_store_memory() const;
  inline void clear_store_memory();
  static const int kStoreMemoryFieldNumber = 5;
  inline const ::trace_format::memory_t& store_memory() const;
  inline ::trace_format::memory_t* mutable_store_memory();
  inline ::trace_format::memory_t* release_store_memory();
  inline void set_allocated_store_memory(::trace_format::memory_t* store_memory);

  // optional bytes reserved_comment = 10;
  inline bool has_reserved_comment() const;
  inline void clear_reserved_comment();
  static const int kReservedCommentFieldNumber = 10;
  inline const ::std::string& reserved_comment() const;
  inline void set_reserved_comment(const ::std::string& value);
  inline void set_reserved_comment(const char* value);
  inline void set_reserved_comment(const void* value, size_t size);
  inline ::std::string* mutable_reserved_comment();
  inline ::std::string* release_reserved_comment();
  inline void set_allocated_reserved_comment(::std::string* reserved_comment);

  // @@protoc_insertion_point(class_scope:trace_format.ins_con_info_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_read_register();
  inline void clear_has_read_register();
  inline void set_has_write_register();
  inline void clear_has_write_register();
  inline void set_has_load_memory();
  inline void clear_has_load_memory();
  inline void set_has_store_memory();
  inline void clear_has_store_memory();
  inline void set_has_reserved_comment();
  inline void clear_has_reserved_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::register_t* read_register_;
  ::trace_format::register_t* write_register_;
  ::trace_format::memory_t* load_memory_;
  ::trace_format::memory_t* store_memory_;
  ::std::string* reserved_comment_;
  int typeid__;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static ins_con_info_t* default_instance_;
};
// -------------------------------------------------------------------

class instruction_t : public ::google::protobuf::Message {
 public:
  instruction_t();
  virtual ~instruction_t();

  instruction_t(const instruction_t& from);

  inline instruction_t& operator=(const instruction_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const instruction_t& default_instance();

  void Swap(instruction_t* other);

  // implements Message ----------------------------------------------

  instruction_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const instruction_t& from);
  void MergeFrom(const instruction_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 thread_id = 1;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 1;
  inline ::google::protobuf::uint32 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint32 value);

  // required .trace_format.address_t address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::trace_format::address_t& address() const;
  inline ::trace_format::address_t* mutable_address();
  inline ::trace_format::address_t* release_address();
  inline void set_allocated_address(::trace_format::address_t* address);

  // required bytes opcode = 3;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 3;
  inline const ::std::string& opcode() const;
  inline void set_opcode(const ::std::string& value);
  inline void set_opcode(const char* value);
  inline void set_opcode(const void* value, size_t size);
  inline ::std::string* mutable_opcode();
  inline ::std::string* release_opcode();
  inline void set_allocated_opcode(::std::string* opcode);

  // repeated .trace_format.ins_con_info_t concrete_info = 4;
  inline int concrete_info_size() const;
  inline void clear_concrete_info();
  static const int kConcreteInfoFieldNumber = 4;
  inline const ::trace_format::ins_con_info_t& concrete_info(int index) const;
  inline ::trace_format::ins_con_info_t* mutable_concrete_info(int index);
  inline ::trace_format::ins_con_info_t* add_concrete_info();
  inline const ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >&
      concrete_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >*
      mutable_concrete_info();

  // required string disassemble = 5;
  inline bool has_disassemble() const;
  inline void clear_disassemble();
  static const int kDisassembleFieldNumber = 5;
  inline const ::std::string& disassemble() const;
  inline void set_disassemble(const ::std::string& value);
  inline void set_disassemble(const char* value);
  inline void set_disassemble(const char* value, size_t size);
  inline ::std::string* mutable_disassemble();
  inline ::std::string* release_disassemble();
  inline void set_allocated_disassemble(::std::string* disassemble);

  // @@protoc_insertion_point(class_scope:trace_format.instruction_t)
 private:
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_disassemble();
  inline void clear_has_disassemble();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::address_t* address_;
  ::std::string* opcode_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t > concrete_info_;
  ::std::string* disassemble_;
  ::google::protobuf::uint32 thread_id_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static instruction_t* default_instance_;
};
// -------------------------------------------------------------------

class body_t : public ::google::protobuf::Message {
 public:
  body_t();
  virtual ~body_t();

  body_t(const body_t& from);

  inline body_t& operator=(const body_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const body_t& default_instance();

  void Swap(body_t* other);

  // implements Message ----------------------------------------------

  body_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const body_t& from);
  void MergeFrom(const body_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_body_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_body_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_body_t value);

  // optional .trace_format.metadata_t metadata = 2;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  inline const ::trace_format::metadata_t& metadata() const;
  inline ::trace_format::metadata_t* mutable_metadata();
  inline ::trace_format::metadata_t* release_metadata();
  inline void set_allocated_metadata(::trace_format::metadata_t* metadata);

  // optional .trace_format.instruction_t instruction = 3;
  inline bool has_instruction() const;
  inline void clear_instruction();
  static const int kInstructionFieldNumber = 3;
  inline const ::trace_format::instruction_t& instruction() const;
  inline ::trace_format::instruction_t* mutable_instruction();
  inline ::trace_format::instruction_t* release_instruction();
  inline void set_allocated_instruction(::trace_format::instruction_t* instruction);

  // @@protoc_insertion_point(class_scope:trace_format.body_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_instruction();
  inline void clear_has_instruction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::metadata_t* metadata_;
  ::trace_format::instruction_t* instruction_;
  int typeid__;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static body_t* default_instance_;
};
// -------------------------------------------------------------------

class chunk_t : public ::google::protobuf::Message {
 public:
  chunk_t();
  virtual ~chunk_t();

  chunk_t(const chunk_t& from);

  inline chunk_t& operator=(const chunk_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chunk_t& default_instance();

  void Swap(chunk_t* other);

  // implements Message ----------------------------------------------

  chunk_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chunk_t& from);
  void MergeFrom(const chunk_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .trace_format.body_t body = 1;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 1;
  inline const ::trace_format::body_t& body(int index) const;
  inline ::trace_format::body_t* mutable_body(int index);
  inline ::trace_format::body_t* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
      mutable_body();

  // @@protoc_insertion_point(class_scope:trace_format.chunk_t)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::body_t > body_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static chunk_t* default_instance_;
};
// -------------------------------------------------------------------

class trace_t : public ::google::protobuf::Message {
 public:
  trace_t();
  virtual ~trace_t();

  trace_t(const trace_t& from);

  inline trace_t& operator=(const trace_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trace_t& default_instance();

  void Swap(trace_t* other);

  // implements Message ----------------------------------------------

  trace_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trace_t& from);
  void MergeFrom(const trace_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.header_t header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::trace_format::header_t& header() const;
  inline ::trace_format::header_t* mutable_header();
  inline ::trace_format::header_t* release_header();
  inline void set_allocated_header(::trace_format::header_t* header);

  // repeated .trace_format.body_t body = 2;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::trace_format::body_t& body(int index) const;
  inline ::trace_format::body_t* mutable_body(int index);
  inline ::trace_format::body_t* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
      mutable_body();

  // @@protoc_insertion_point(class_scope:trace_format.trace_t)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::trace_format::header_t* header_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::body_t > body_;
  friend void  protobuf_AddDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_AssignDesc_trace_5fwith_5fchunk_2eproto();
  friend void protobuf_ShutdownFile_trace_5fwith_5fchunk_2eproto();

  void InitAsDefaultInstance();
  static trace_t* default_instance_;
};
// ===================================================================


// ===================================================================

// address_t

// required .trace_format.typeid_address_t typeid = 1;
inline bool address_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void address_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void address_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void address_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_address_t address_t::typeid_() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.typeid)
  return static_cast< ::trace_format::typeid_address_t >(typeid__);
}
inline void address_t::set_typeid_(::trace_format::typeid_address_t value) {
  assert(::trace_format::typeid_address_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.typeid)
}

// optional uint32 value_8 = 2;
inline bool address_t::has_value_8() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void address_t::set_has_value_8() {
  _has_bits_[0] |= 0x00000002u;
}
inline void address_t::clear_has_value_8() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void address_t::clear_value_8() {
  value_8_ = 0u;
  clear_has_value_8();
}
inline ::google::protobuf::uint32 address_t::value_8() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_8)
  return value_8_;
}
inline void address_t::set_value_8(::google::protobuf::uint32 value) {
  set_has_value_8();
  value_8_ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_8)
}

// optional uint32 value_16 = 3;
inline bool address_t::has_value_16() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void address_t::set_has_value_16() {
  _has_bits_[0] |= 0x00000004u;
}
inline void address_t::clear_has_value_16() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void address_t::clear_value_16() {
  value_16_ = 0u;
  clear_has_value_16();
}
inline ::google::protobuf::uint32 address_t::value_16() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_16)
  return value_16_;
}
inline void address_t::set_value_16(::google::protobuf::uint32 value) {
  set_has_value_16();
  value_16_ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_16)
}

// optional uint32 value_32 = 4;
inline bool address_t::has_value_32() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void address_t::set_has_value_32() {
  _has_bits_[0] |= 0x00000008u;
}
inline void address_t::clear_has_value_32() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void address_t::clear_value_32() {
  value_32_ = 0u;
  clear_has_value_32();
}
inline ::google::protobuf::uint32 address_t::value_32() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_32)
  return value_32_;
}
inline void address_t::set_value_32(::google::protobuf::uint32 value) {
  set_has_value_32();
  value_32_ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_32)
}

// optional uint64 value_64 = 5;
inline bool address_t::has_value_64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void address_t::set_has_value_64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void address_t::clear_has_value_64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void address_t::clear_value_64() {
  value_64_ = GOOGLE_ULONGLONG(0);
  clear_has_value_64();
}
inline ::google::protobuf::uint64 address_t::value_64() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_64)
  return value_64_;
}
inline void address_t::set_value_64(::google::protobuf::uint64 value) {
  set_has_value_64();
  value_64_ = value;
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_64)
}

// optional bytes value_128 = 6;
inline bool address_t::has_value_128() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void address_t::set_has_value_128() {
  _has_bits_[0] |= 0x00000020u;
}
inline void address_t::clear_has_value_128() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void address_t::clear_value_128() {
  if (value_128_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_128_->clear();
  }
  clear_has_value_128();
}
inline const ::std::string& address_t::value_128() const {
  // @@protoc_insertion_point(field_get:trace_format.address_t.value_128)
  return *value_128_;
}
inline void address_t::set_value_128(const ::std::string& value) {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_128_ = new ::std::string;
  }
  value_128_->assign(value);
  // @@protoc_insertion_point(field_set:trace_format.address_t.value_128)
}
inline void address_t::set_value_128(const char* value) {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_128_ = new ::std::string;
  }
  value_128_->assign(value);
  // @@protoc_insertion_point(field_set_char:trace_format.address_t.value_128)
}
inline void address_t::set_value_128(const void* value, size_t size) {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_128_ = new ::std::string;
  }
  value_128_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trace_format.address_t.value_128)
}
inline ::std::string* address_t::mutable_value_128() {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_128_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.address_t.value_128)
  return value_128_;
}
inline ::std::string* address_t::release_value_128() {
  clear_has_value_128();
  if (value_128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_128_;
    value_128_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void address_t::set_allocated_value_128(::std::string* value_128) {
  if (value_128_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_128_;
  }
  if (value_128) {
    set_has_value_128();
    value_128_ = value_128;
  } else {
    clear_has_value_128();
    value_128_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.address_t.value_128)
}

// -------------------------------------------------------------------

// header_t

// required .trace_format.architecture_t architecture = 1;
inline bool header_t::has_architecture() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void header_t::set_has_architecture() {
  _has_bits_[0] |= 0x00000001u;
}
inline void header_t::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void header_t::clear_architecture() {
  architecture_ = 0;
  clear_has_architecture();
}
inline ::trace_format::architecture_t header_t::architecture() const {
  // @@protoc_insertion_point(field_get:trace_format.header_t.architecture)
  return static_cast< ::trace_format::architecture_t >(architecture_);
}
inline void header_t::set_architecture(::trace_format::architecture_t value) {
  assert(::trace_format::architecture_t_IsValid(value));
  set_has_architecture();
  architecture_ = value;
  // @@protoc_insertion_point(field_set:trace_format.header_t.architecture)
}

// required .trace_format.typeid_address_t address_size = 2;
inline bool header_t::has_address_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void header_t::set_has_address_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void header_t::clear_has_address_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void header_t::clear_address_size() {
  address_size_ = 0;
  clear_has_address_size();
}
inline ::trace_format::typeid_address_t header_t::address_size() const {
  // @@protoc_insertion_point(field_get:trace_format.header_t.address_size)
  return static_cast< ::trace_format::typeid_address_t >(address_size_);
}
inline void header_t::set_address_size(::trace_format::typeid_address_t value) {
  assert(::trace_format::typeid_address_t_IsValid(value));
  set_has_address_size();
  address_size_ = value;
  // @@protoc_insertion_point(field_set:trace_format.header_t.address_size)
}

// -------------------------------------------------------------------

// module_t

// required string name = 1;
inline bool module_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void module_t::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void module_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void module_t::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& module_t::name() const {
  // @@protoc_insertion_point(field_get:trace_format.module_t.name)
  return *name_;
}
inline void module_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:trace_format.module_t.name)
}
inline void module_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:trace_format.module_t.name)
}
inline void module_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trace_format.module_t.name)
}
inline ::std::string* module_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.module_t.name)
  return name_;
}
inline ::std::string* module_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void module_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.module_t.name)
}

// -------------------------------------------------------------------

// exception_t

// required uint32 type_exception = 1;
inline bool exception_t::has_type_exception() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exception_t::set_has_type_exception() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exception_t::clear_has_type_exception() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exception_t::clear_type_exception() {
  type_exception_ = 0u;
  clear_has_type_exception();
}
inline ::google::protobuf::uint32 exception_t::type_exception() const {
  // @@protoc_insertion_point(field_get:trace_format.exception_t.type_exception)
  return type_exception_;
}
inline void exception_t::set_type_exception(::google::protobuf::uint32 value) {
  set_has_type_exception();
  type_exception_ = value;
  // @@protoc_insertion_point(field_set:trace_format.exception_t.type_exception)
}

// required .trace_format.address_t handler = 2;
inline bool exception_t::has_handler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exception_t::set_has_handler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exception_t::clear_has_handler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exception_t::clear_handler() {
  if (handler_ != NULL) handler_->::trace_format::address_t::Clear();
  clear_has_handler();
}
inline const ::trace_format::address_t& exception_t::handler() const {
  // @@protoc_insertion_point(field_get:trace_format.exception_t.handler)
  return handler_ != NULL ? *handler_ : *default_instance_->handler_;
}
inline ::trace_format::address_t* exception_t::mutable_handler() {
  set_has_handler();
  if (handler_ == NULL) handler_ = new ::trace_format::address_t;
  // @@protoc_insertion_point(field_mutable:trace_format.exception_t.handler)
  return handler_;
}
inline ::trace_format::address_t* exception_t::release_handler() {
  clear_has_handler();
  ::trace_format::address_t* temp = handler_;
  handler_ = NULL;
  return temp;
}
inline void exception_t::set_allocated_handler(::trace_format::address_t* handler) {
  delete handler_;
  handler_ = handler;
  if (handler) {
    set_has_handler();
  } else {
    clear_has_handler();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.exception_t.handler)
}

// -------------------------------------------------------------------

// metadata_t

// required .trace_format.typeid_metadata_t typeid = 1;
inline bool metadata_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metadata_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metadata_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metadata_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_metadata_t metadata_t::typeid_() const {
  // @@protoc_insertion_point(field_get:trace_format.metadata_t.typeid)
  return static_cast< ::trace_format::typeid_metadata_t >(typeid__);
}
inline void metadata_t::set_typeid_(::trace_format::typeid_metadata_t value) {
  assert(::trace_format::typeid_metadata_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:trace_format.metadata_t.typeid)
}

// optional .trace_format.module_t module_metadata = 2;
inline bool metadata_t::has_module_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void metadata_t::set_has_module_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void metadata_t::clear_has_module_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void metadata_t::clear_module_metadata() {
  if (module_metadata_ != NULL) module_metadata_->::trace_format::module_t::Clear();
  clear_has_module_metadata();
}
inline const ::trace_format::module_t& metadata_t::module_metadata() const {
  // @@protoc_insertion_point(field_get:trace_format.metadata_t.module_metadata)
  return module_metadata_ != NULL ? *module_metadata_ : *default_instance_->module_metadata_;
}
inline ::trace_format::module_t* metadata_t::mutable_module_metadata() {
  set_has_module_metadata();
  if (module_metadata_ == NULL) module_metadata_ = new ::trace_format::module_t;
  // @@protoc_insertion_point(field_mutable:trace_format.metadata_t.module_metadata)
  return module_metadata_;
}
inline ::trace_format::module_t* metadata_t::release_module_metadata() {
  clear_has_module_metadata();
  ::trace_format::module_t* temp = module_metadata_;
  module_metadata_ = NULL;
  return temp;
}
inline void metadata_t::set_allocated_module_metadata(::trace_format::module_t* module_metadata) {
  delete module_metadata_;
  module_metadata_ = module_metadata;
  if (module_metadata) {
    set_has_module_metadata();
  } else {
    clear_has_module_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.metadata_t.module_metadata)
}

// optional .trace_format.exception_t exception_metadata = 3;
inline bool metadata_t::has_exception_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void metadata_t::set_has_exception_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void metadata_t::clear_has_exception_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void metadata_t::clear_exception_metadata() {
  if (exception_metadata_ != NULL) exception_metadata_->::trace_format::exception_t::Clear();
  clear_has_exception_metadata();
}
inline const ::trace_format::exception_t& metadata_t::exception_metadata() const {
  // @@protoc_insertion_point(field_get:trace_format.metadata_t.exception_metadata)
  return exception_metadata_ != NULL ? *exception_metadata_ : *default_instance_->exception_metadata_;
}
inline ::trace_format::exception_t* metadata_t::mutable_exception_metadata() {
  set_has_exception_metadata();
  if (exception_metadata_ == NULL) exception_metadata_ = new ::trace_format::exception_t;
  // @@protoc_insertion_point(field_mutable:trace_format.metadata_t.exception_metadata)
  return exception_metadata_;
}
inline ::trace_format::exception_t* metadata_t::release_exception_metadata() {
  clear_has_exception_metadata();
  ::trace_format::exception_t* temp = exception_metadata_;
  exception_metadata_ = NULL;
  return temp;
}
inline void metadata_t::set_allocated_exception_metadata(::trace_format::exception_t* exception_metadata) {
  delete exception_metadata_;
  exception_metadata_ = exception_metadata;
  if (exception_metadata) {
    set_has_exception_metadata();
  } else {
    clear_has_exception_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.metadata_t.exception_metadata)
}

// optional uint32 wave_metadata = 4;
inline bool metadata_t::has_wave_metadata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void metadata_t::set_has_wave_metadata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void metadata_t::clear_has_wave_metadata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void metadata_t::clear_wave_metadata() {
  wave_metadata_ = 0u;
  clear_has_wave_metadata();
}
inline ::google::protobuf::uint32 metadata_t::wave_metadata() const {
  // @@protoc_insertion_point(field_get:trace_format.metadata_t.wave_metadata)
  return wave_metadata_;
}
inline void metadata_t::set_wave_metadata(::google::protobuf::uint32 value) {
  set_has_wave_metadata();
  wave_metadata_ = value;
  // @@protoc_insertion_point(field_set:trace_format.metadata_t.wave_metadata)
}

// -------------------------------------------------------------------

// register_t

// required string name = 1;
inline bool register_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void register_t::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void register_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void register_t::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& register_t::name() const {
  // @@protoc_insertion_point(field_get:trace_format.register_t.name)
  return *name_;
}
inline void register_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:trace_format.register_t.name)
}
inline void register_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:trace_format.register_t.name)
}
inline void register_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trace_format.register_t.name)
}
inline ::std::string* register_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.register_t.name)
  return name_;
}
inline ::std::string* register_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void register_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.register_t.name)
}

// required .trace_format.address_t value = 2;
inline bool register_t::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void register_t::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void register_t::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void register_t::clear_value() {
  if (value_ != NULL) value_->::trace_format::address_t::Clear();
  clear_has_value();
}
inline const ::trace_format::address_t& register_t::value() const {
  // @@protoc_insertion_point(field_get:trace_format.register_t.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::trace_format::address_t* register_t::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::trace_format::address_t;
  // @@protoc_insertion_point(field_mutable:trace_format.register_t.value)
  return value_;
}
inline ::trace_format::address_t* register_t::release_value() {
  clear_has_value();
  ::trace_format::address_t* temp = value_;
  value_ = NULL;
  return temp;
}
inline void register_t::set_allocated_value(::trace_format::address_t* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.register_t.value)
}

// -------------------------------------------------------------------

// memory_t

// required .trace_format.address_t address = 1;
inline bool memory_t::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memory_t::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memory_t::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memory_t::clear_address() {
  if (address_ != NULL) address_->::trace_format::address_t::Clear();
  clear_has_address();
}
inline const ::trace_format::address_t& memory_t::address() const {
  // @@protoc_insertion_point(field_get:trace_format.memory_t.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::trace_format::address_t* memory_t::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::trace_format::address_t;
  // @@protoc_insertion_point(field_mutable:trace_format.memory_t.address)
  return address_;
}
inline ::trace_format::address_t* memory_t::release_address() {
  clear_has_address();
  ::trace_format::address_t* temp = address_;
  address_ = NULL;
  return temp;
}
inline void memory_t::set_allocated_address(::trace_format::address_t* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.memory_t.address)
}

// required .trace_format.address_t value = 2;
inline bool memory_t::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memory_t::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memory_t::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memory_t::clear_value() {
  if (value_ != NULL) value_->::trace_format::address_t::Clear();
  clear_has_value();
}
inline const ::trace_format::address_t& memory_t::value() const {
  // @@protoc_insertion_point(field_get:trace_format.memory_t.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::trace_format::address_t* memory_t::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::trace_format::address_t;
  // @@protoc_insertion_point(field_mutable:trace_format.memory_t.value)
  return value_;
}
inline ::trace_format::address_t* memory_t::release_value() {
  clear_has_value();
  ::trace_format::address_t* temp = value_;
  value_ = NULL;
  return temp;
}
inline void memory_t::set_allocated_value(::trace_format::address_t* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.memory_t.value)
}

// -------------------------------------------------------------------

// ins_con_info_t

// required .trace_format.typeid_con_info_t typeid = 1;
inline bool ins_con_info_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ins_con_info_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ins_con_info_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ins_con_info_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_con_info_t ins_con_info_t::typeid_() const {
  // @@protoc_insertion_point(field_get:trace_format.ins_con_info_t.typeid)
  return static_cast< ::trace_format::typeid_con_info_t >(typeid__);
}
inline void ins_con_info_t::set_typeid_(::trace_format::typeid_con_info_t value) {
  assert(::trace_format::typeid_con_info_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:trace_format.ins_con_info_t.typeid)
}

// optional .trace_format.register_t read_register = 2;
inline bool ins_con_info_t::has_read_register() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ins_con_info_t::set_has_read_register() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ins_con_info_t::clear_has_read_register() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ins_con_info_t::clear_read_register() {
  if (read_register_ != NULL) read_register_->::trace_format::register_t::Clear();
  clear_has_read_register();
}
inline const ::trace_format::register_t& ins_con_info_t::read_register() const {
  // @@protoc_insertion_point(field_get:trace_format.ins_con_info_t.read_register)
  return read_register_ != NULL ? *read_register_ : *default_instance_->read_register_;
}
inline ::trace_format::register_t* ins_con_info_t::mutable_read_register() {
  set_has_read_register();
  if (read_register_ == NULL) read_register_ = new ::trace_format::register_t;
  // @@protoc_insertion_point(field_mutable:trace_format.ins_con_info_t.read_register)
  return read_register_;
}
inline ::trace_format::register_t* ins_con_info_t::release_read_register() {
  clear_has_read_register();
  ::trace_format::register_t* temp = read_register_;
  read_register_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_read_register(::trace_format::register_t* read_register) {
  delete read_register_;
  read_register_ = read_register;
  if (read_register) {
    set_has_read_register();
  } else {
    clear_has_read_register();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.read_register)
}

// optional .trace_format.register_t write_register = 3;
inline bool ins_con_info_t::has_write_register() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ins_con_info_t::set_has_write_register() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ins_con_info_t::clear_has_write_register() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ins_con_info_t::clear_write_register() {
  if (write_register_ != NULL) write_register_->::trace_format::register_t::Clear();
  clear_has_write_register();
}
inline const ::trace_format::register_t& ins_con_info_t::write_register() const {
  // @@protoc_insertion_point(field_get:trace_format.ins_con_info_t.write_register)
  return write_register_ != NULL ? *write_register_ : *default_instance_->write_register_;
}
inline ::trace_format::register_t* ins_con_info_t::mutable_write_register() {
  set_has_write_register();
  if (write_register_ == NULL) write_register_ = new ::trace_format::register_t;
  // @@protoc_insertion_point(field_mutable:trace_format.ins_con_info_t.write_register)
  return write_register_;
}
inline ::trace_format::register_t* ins_con_info_t::release_write_register() {
  clear_has_write_register();
  ::trace_format::register_t* temp = write_register_;
  write_register_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_write_register(::trace_format::register_t* write_register) {
  delete write_register_;
  write_register_ = write_register;
  if (write_register) {
    set_has_write_register();
  } else {
    clear_has_write_register();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.write_register)
}

// optional .trace_format.memory_t load_memory = 4;
inline bool ins_con_info_t::has_load_memory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ins_con_info_t::set_has_load_memory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ins_con_info_t::clear_has_load_memory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ins_con_info_t::clear_load_memory() {
  if (load_memory_ != NULL) load_memory_->::trace_format::memory_t::Clear();
  clear_has_load_memory();
}
inline const ::trace_format::memory_t& ins_con_info_t::load_memory() const {
  // @@protoc_insertion_point(field_get:trace_format.ins_con_info_t.load_memory)
  return load_memory_ != NULL ? *load_memory_ : *default_instance_->load_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::mutable_load_memory() {
  set_has_load_memory();
  if (load_memory_ == NULL) load_memory_ = new ::trace_format::memory_t;
  // @@protoc_insertion_point(field_mutable:trace_format.ins_con_info_t.load_memory)
  return load_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::release_load_memory() {
  clear_has_load_memory();
  ::trace_format::memory_t* temp = load_memory_;
  load_memory_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_load_memory(::trace_format::memory_t* load_memory) {
  delete load_memory_;
  load_memory_ = load_memory;
  if (load_memory) {
    set_has_load_memory();
  } else {
    clear_has_load_memory();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.load_memory)
}

// optional .trace_format.memory_t store_memory = 5;
inline bool ins_con_info_t::has_store_memory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ins_con_info_t::set_has_store_memory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ins_con_info_t::clear_has_store_memory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ins_con_info_t::clear_store_memory() {
  if (store_memory_ != NULL) store_memory_->::trace_format::memory_t::Clear();
  clear_has_store_memory();
}
inline const ::trace_format::memory_t& ins_con_info_t::store_memory() const {
  // @@protoc_insertion_point(field_get:trace_format.ins_con_info_t.store_memory)
  return store_memory_ != NULL ? *store_memory_ : *default_instance_->store_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::mutable_store_memory() {
  set_has_store_memory();
  if (store_memory_ == NULL) store_memory_ = new ::trace_format::memory_t;
  // @@protoc_insertion_point(field_mutable:trace_format.ins_con_info_t.store_memory)
  return store_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::release_store_memory() {
  clear_has_store_memory();
  ::trace_format::memory_t* temp = store_memory_;
  store_memory_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_store_memory(::trace_format::memory_t* store_memory) {
  delete store_memory_;
  store_memory_ = store_memory;
  if (store_memory) {
    set_has_store_memory();
  } else {
    clear_has_store_memory();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.store_memory)
}

// optional bytes reserved_comment = 10;
inline bool ins_con_info_t::has_reserved_comment() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ins_con_info_t::set_has_reserved_comment() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ins_con_info_t::clear_has_reserved_comment() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ins_con_info_t::clear_reserved_comment() {
  if (reserved_comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reserved_comment_->clear();
  }
  clear_has_reserved_comment();
}
inline const ::std::string& ins_con_info_t::reserved_comment() const {
  // @@protoc_insertion_point(field_get:trace_format.ins_con_info_t.reserved_comment)
  return *reserved_comment_;
}
inline void ins_con_info_t::set_reserved_comment(const ::std::string& value) {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reserved_comment_ = new ::std::string;
  }
  reserved_comment_->assign(value);
  // @@protoc_insertion_point(field_set:trace_format.ins_con_info_t.reserved_comment)
}
inline void ins_con_info_t::set_reserved_comment(const char* value) {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reserved_comment_ = new ::std::string;
  }
  reserved_comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:trace_format.ins_con_info_t.reserved_comment)
}
inline void ins_con_info_t::set_reserved_comment(const void* value, size_t size) {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reserved_comment_ = new ::std::string;
  }
  reserved_comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trace_format.ins_con_info_t.reserved_comment)
}
inline ::std::string* ins_con_info_t::mutable_reserved_comment() {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reserved_comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.ins_con_info_t.reserved_comment)
  return reserved_comment_;
}
inline ::std::string* ins_con_info_t::release_reserved_comment() {
  clear_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reserved_comment_;
    reserved_comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ins_con_info_t::set_allocated_reserved_comment(::std::string* reserved_comment) {
  if (reserved_comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reserved_comment_;
  }
  if (reserved_comment) {
    set_has_reserved_comment();
    reserved_comment_ = reserved_comment;
  } else {
    clear_has_reserved_comment();
    reserved_comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.reserved_comment)
}

// -------------------------------------------------------------------

// instruction_t

// required uint32 thread_id = 1;
inline bool instruction_t::has_thread_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void instruction_t::set_has_thread_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void instruction_t::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void instruction_t::clear_thread_id() {
  thread_id_ = 0u;
  clear_has_thread_id();
}
inline ::google::protobuf::uint32 instruction_t::thread_id() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.thread_id)
  return thread_id_;
}
inline void instruction_t::set_thread_id(::google::protobuf::uint32 value) {
  set_has_thread_id();
  thread_id_ = value;
  // @@protoc_insertion_point(field_set:trace_format.instruction_t.thread_id)
}

// required .trace_format.address_t address = 2;
inline bool instruction_t::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void instruction_t::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void instruction_t::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void instruction_t::clear_address() {
  if (address_ != NULL) address_->::trace_format::address_t::Clear();
  clear_has_address();
}
inline const ::trace_format::address_t& instruction_t::address() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::trace_format::address_t* instruction_t::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::trace_format::address_t;
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.address)
  return address_;
}
inline ::trace_format::address_t* instruction_t::release_address() {
  clear_has_address();
  ::trace_format::address_t* temp = address_;
  address_ = NULL;
  return temp;
}
inline void instruction_t::set_allocated_address(::trace_format::address_t* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.instruction_t.address)
}

// required bytes opcode = 3;
inline bool instruction_t::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void instruction_t::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void instruction_t::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void instruction_t::clear_opcode() {
  if (opcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opcode_->clear();
  }
  clear_has_opcode();
}
inline const ::std::string& instruction_t::opcode() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.opcode)
  return *opcode_;
}
inline void instruction_t::set_opcode(const ::std::string& value) {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opcode_ = new ::std::string;
  }
  opcode_->assign(value);
  // @@protoc_insertion_point(field_set:trace_format.instruction_t.opcode)
}
inline void instruction_t::set_opcode(const char* value) {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opcode_ = new ::std::string;
  }
  opcode_->assign(value);
  // @@protoc_insertion_point(field_set_char:trace_format.instruction_t.opcode)
}
inline void instruction_t::set_opcode(const void* value, size_t size) {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opcode_ = new ::std::string;
  }
  opcode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trace_format.instruction_t.opcode)
}
inline ::std::string* instruction_t::mutable_opcode() {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opcode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.opcode)
  return opcode_;
}
inline ::std::string* instruction_t::release_opcode() {
  clear_has_opcode();
  if (opcode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = opcode_;
    opcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void instruction_t::set_allocated_opcode(::std::string* opcode) {
  if (opcode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete opcode_;
  }
  if (opcode) {
    set_has_opcode();
    opcode_ = opcode;
  } else {
    clear_has_opcode();
    opcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.instruction_t.opcode)
}

// repeated .trace_format.ins_con_info_t concrete_info = 4;
inline int instruction_t::concrete_info_size() const {
  return concrete_info_.size();
}
inline void instruction_t::clear_concrete_info() {
  concrete_info_.Clear();
}
inline const ::trace_format::ins_con_info_t& instruction_t::concrete_info(int index) const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.concrete_info)
  return concrete_info_.Get(index);
}
inline ::trace_format::ins_con_info_t* instruction_t::mutable_concrete_info(int index) {
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.concrete_info)
  return concrete_info_.Mutable(index);
}
inline ::trace_format::ins_con_info_t* instruction_t::add_concrete_info() {
  // @@protoc_insertion_point(field_add:trace_format.instruction_t.concrete_info)
  return concrete_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >&
instruction_t::concrete_info() const {
  // @@protoc_insertion_point(field_list:trace_format.instruction_t.concrete_info)
  return concrete_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >*
instruction_t::mutable_concrete_info() {
  // @@protoc_insertion_point(field_mutable_list:trace_format.instruction_t.concrete_info)
  return &concrete_info_;
}

// required string disassemble = 5;
inline bool instruction_t::has_disassemble() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void instruction_t::set_has_disassemble() {
  _has_bits_[0] |= 0x00000010u;
}
inline void instruction_t::clear_has_disassemble() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void instruction_t::clear_disassemble() {
  if (disassemble_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disassemble_->clear();
  }
  clear_has_disassemble();
}
inline const ::std::string& instruction_t::disassemble() const {
  // @@protoc_insertion_point(field_get:trace_format.instruction_t.disassemble)
  return *disassemble_;
}
inline void instruction_t::set_disassemble(const ::std::string& value) {
  set_has_disassemble();
  if (disassemble_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disassemble_ = new ::std::string;
  }
  disassemble_->assign(value);
  // @@protoc_insertion_point(field_set:trace_format.instruction_t.disassemble)
}
inline void instruction_t::set_disassemble(const char* value) {
  set_has_disassemble();
  if (disassemble_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disassemble_ = new ::std::string;
  }
  disassemble_->assign(value);
  // @@protoc_insertion_point(field_set_char:trace_format.instruction_t.disassemble)
}
inline void instruction_t::set_disassemble(const char* value, size_t size) {
  set_has_disassemble();
  if (disassemble_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disassemble_ = new ::std::string;
  }
  disassemble_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:trace_format.instruction_t.disassemble)
}
inline ::std::string* instruction_t::mutable_disassemble() {
  set_has_disassemble();
  if (disassemble_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    disassemble_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:trace_format.instruction_t.disassemble)
  return disassemble_;
}
inline ::std::string* instruction_t::release_disassemble() {
  clear_has_disassemble();
  if (disassemble_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = disassemble_;
    disassemble_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void instruction_t::set_allocated_disassemble(::std::string* disassemble) {
  if (disassemble_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete disassemble_;
  }
  if (disassemble) {
    set_has_disassemble();
    disassemble_ = disassemble;
  } else {
    clear_has_disassemble();
    disassemble_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.instruction_t.disassemble)
}

// -------------------------------------------------------------------

// body_t

// required .trace_format.typeid_body_t typeid = 1;
inline bool body_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void body_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void body_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void body_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_body_t body_t::typeid_() const {
  // @@protoc_insertion_point(field_get:trace_format.body_t.typeid)
  return static_cast< ::trace_format::typeid_body_t >(typeid__);
}
inline void body_t::set_typeid_(::trace_format::typeid_body_t value) {
  assert(::trace_format::typeid_body_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:trace_format.body_t.typeid)
}

// optional .trace_format.metadata_t metadata = 2;
inline bool body_t::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void body_t::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void body_t::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void body_t::clear_metadata() {
  if (metadata_ != NULL) metadata_->::trace_format::metadata_t::Clear();
  clear_has_metadata();
}
inline const ::trace_format::metadata_t& body_t::metadata() const {
  // @@protoc_insertion_point(field_get:trace_format.body_t.metadata)
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::trace_format::metadata_t* body_t::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::trace_format::metadata_t;
  // @@protoc_insertion_point(field_mutable:trace_format.body_t.metadata)
  return metadata_;
}
inline ::trace_format::metadata_t* body_t::release_metadata() {
  clear_has_metadata();
  ::trace_format::metadata_t* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void body_t::set_allocated_metadata(::trace_format::metadata_t* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.body_t.metadata)
}

// optional .trace_format.instruction_t instruction = 3;
inline bool body_t::has_instruction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void body_t::set_has_instruction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void body_t::clear_has_instruction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void body_t::clear_instruction() {
  if (instruction_ != NULL) instruction_->::trace_format::instruction_t::Clear();
  clear_has_instruction();
}
inline const ::trace_format::instruction_t& body_t::instruction() const {
  // @@protoc_insertion_point(field_get:trace_format.body_t.instruction)
  return instruction_ != NULL ? *instruction_ : *default_instance_->instruction_;
}
inline ::trace_format::instruction_t* body_t::mutable_instruction() {
  set_has_instruction();
  if (instruction_ == NULL) instruction_ = new ::trace_format::instruction_t;
  // @@protoc_insertion_point(field_mutable:trace_format.body_t.instruction)
  return instruction_;
}
inline ::trace_format::instruction_t* body_t::release_instruction() {
  clear_has_instruction();
  ::trace_format::instruction_t* temp = instruction_;
  instruction_ = NULL;
  return temp;
}
inline void body_t::set_allocated_instruction(::trace_format::instruction_t* instruction) {
  delete instruction_;
  instruction_ = instruction;
  if (instruction) {
    set_has_instruction();
  } else {
    clear_has_instruction();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.body_t.instruction)
}

// -------------------------------------------------------------------

// chunk_t

// repeated .trace_format.body_t body = 1;
inline int chunk_t::body_size() const {
  return body_.size();
}
inline void chunk_t::clear_body() {
  body_.Clear();
}
inline const ::trace_format::body_t& chunk_t::body(int index) const {
  // @@protoc_insertion_point(field_get:trace_format.chunk_t.body)
  return body_.Get(index);
}
inline ::trace_format::body_t* chunk_t::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:trace_format.chunk_t.body)
  return body_.Mutable(index);
}
inline ::trace_format::body_t* chunk_t::add_body() {
  // @@protoc_insertion_point(field_add:trace_format.chunk_t.body)
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
chunk_t::body() const {
  // @@protoc_insertion_point(field_list:trace_format.chunk_t.body)
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
chunk_t::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:trace_format.chunk_t.body)
  return &body_;
}

// -------------------------------------------------------------------

// trace_t

// required .trace_format.header_t header = 1;
inline bool trace_t::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void trace_t::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void trace_t::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void trace_t::clear_header() {
  if (header_ != NULL) header_->::trace_format::header_t::Clear();
  clear_has_header();
}
inline const ::trace_format::header_t& trace_t::header() const {
  // @@protoc_insertion_point(field_get:trace_format.trace_t.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::trace_format::header_t* trace_t::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::trace_format::header_t;
  // @@protoc_insertion_point(field_mutable:trace_format.trace_t.header)
  return header_;
}
inline ::trace_format::header_t* trace_t::release_header() {
  clear_has_header();
  ::trace_format::header_t* temp = header_;
  header_ = NULL;
  return temp;
}
inline void trace_t::set_allocated_header(::trace_format::header_t* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.trace_t.header)
}

// repeated .trace_format.body_t body = 2;
inline int trace_t::body_size() const {
  return body_.size();
}
inline void trace_t::clear_body() {
  body_.Clear();
}
inline const ::trace_format::body_t& trace_t::body(int index) const {
  // @@protoc_insertion_point(field_get:trace_format.trace_t.body)
  return body_.Get(index);
}
inline ::trace_format::body_t* trace_t::mutable_body(int index) {
  // @@protoc_insertion_point(field_mutable:trace_format.trace_t.body)
  return body_.Mutable(index);
}
inline ::trace_format::body_t* trace_t::add_body() {
  // @@protoc_insertion_point(field_add:trace_format.trace_t.body)
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
trace_t::body() const {
  // @@protoc_insertion_point(field_list:trace_format.trace_t.body)
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
trace_t::mutable_body() {
  // @@protoc_insertion_point(field_mutable_list:trace_format.trace_t.body)
  return &body_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace trace_format

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::trace_format::architecture_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::architecture_t>() {
  return ::trace_format::architecture_t_descriptor();
}
template <> struct is_proto_enum< ::trace_format::typeid_address_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_address_t>() {
  return ::trace_format::typeid_address_t_descriptor();
}
template <> struct is_proto_enum< ::trace_format::typeid_metadata_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_metadata_t>() {
  return ::trace_format::typeid_metadata_t_descriptor();
}
template <> struct is_proto_enum< ::trace_format::typeid_con_info_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_con_info_t>() {
  return ::trace_format::typeid_con_info_t_descriptor();
}
template <> struct is_proto_enum< ::trace_format::typeid_body_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_body_t>() {
  return ::trace_format::typeid_body_t_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trace_5fwith_5fchunk_2eproto__INCLUDED
